(ns jirgee.services.auth
  (:require [jirgee.services.base :refer [client set-auth-header! safe-get-response]]
            [jirgee.services.storage :as storage]))

;; --- Authentication Operations ---

;; Login
(defn login [{:keys [email password]} on-success on-error]
  (println "[Auth] login 被调用, email:" (pr-str email))
  (-> (.post client "/auth/login"
             .data {"email" email "password" password})
      (.then (fn [resp]
               (println "[Auth] 登录请求成功, resp.data:" (pr-str (.-data resp)))
               (let [data (.-data resp)
                     token (get data "token")
                     user (get data "user")]
                 (println "[Auth] 提取 token:" (pr-str token) "user:" (pr-str user))
                 ;; 1. Inject Token into Dio global config
                 (set-auth-header! token)
                 ;; 2. Save Token and user info to SharedPreferences
                 (storage/save-auth-data! token user)
                 ;; 3. Execute success callback, return user info
                 (on-success data))))
      (.catchError (fn [err]
                     (println "[Auth] 登录请求失败 err:" (pr-str err))
                     (when-let [resp (safe-get-response err)]
                       (println "[Auth] 响应状态码:" (.-statusCode resp))
                       (println "[Auth] 响应数据:" (pr-str (.-data resp))))
                     ;; Possible errors: 401 (wrong password), 404 (user not found)
                     (on-error err)))))

;; Register: API 要求 user 含 email, username, password, display_name（见 API.md）
(defn register [user-params on-success on-error]
  (println "[Auth] register 被调用, user-params:" (pr-str user-params))
  (let [nickname (or (get user-params "nickname") (get user-params "username") "")
        api-user (-> user-params
                     (dissoc "nickname")
                     (assoc "username" nickname "display_name" nickname))
        payload {"user" api-user}]
    (println "[Auth] 请求 payload:" (pr-str payload))
    (-> (.post client "/auth/register" .data payload)
        (.then (fn [resp]
                 (println "[Auth] 注册请求成功, resp.data:" (pr-str (.-data resp)))
                 (let [data (.-data resp)
                       token (get data "token")
                       user (get data "user")]
                   ;; 1. Inject Token into Dio global config
                   (set-auth-header! token)
                   ;; 2. Save Token and user info to SharedPreferences
                   (storage/save-auth-data! token user)
                   ;; 3. Execute success callback
                   (on-success data))))
        (.catchError (fn [err]
                       (println "[Auth] 注册请求失败 err:" (pr-str err))
                       (when-let [resp (safe-get-response err)]
                         (println "[Auth] 响应状态码:" (.-statusCode resp))
                         (println "[Auth] 响应数据:" (pr-str (.-data resp))))
                       (on-error err))))))

;; Logout
(defn logout [on-success]
  ;; 1. Clear token from Dio Header
  (set-auth-header! nil)
  ;; 2. Clear locally persisted token and user info from SharedPreferences
  (-> (storage/clear-auth-data!)
      (.then (fn [_] (on-success true)))
      (.catchError (fn [err]
                     (println "Failed to clear auth data:" err)
                     (on-success true)))))

;; --- Password Management ---

;; Request password reset email
(defn forgot-password [email on-success on-error]
  (-> (.post client "/auth/forgot_password" .data {"email" email})
      (.then (fn [resp] (on-success (into {} (.-data resp)))))
      (.catchError on-error)))

;; Change password using reset token
(defn reset-password [{:keys [token password password-confirmation]} on-success on-error]
  (-> (.post client "/auth/reset_password"
             .data {"token" token
                    "password" password
                    "password_confirmation" password-confirmation})
      (.then (fn [resp] (on-success (into {} (.-data resp)))))
      (.catchError on-error)))

;; Change password while logged in
(defn change-password [{:keys [current-password new-password]} on-success on-error]
  (-> (.post client "/auth/change_password"
             .data {"current_password" current-password
                    "new_password" new-password})
      (.then (fn [resp] (on-success (into {} (.-data resp)))))
      (.catchError on-error)))