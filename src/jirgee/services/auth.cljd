(ns jirgee.services.auth
  (:require [jirgee.services.base :refer [client set-auth-header! safe-get-response]]
            [jirgee.services.storage :as storage]
            [jirgee.state :refer [set-current-user!]]))

;; --- Authentication Operations ---

;; Login
(defn login [{:keys [email password]} on-success on-error]
  (println "[Auth] login called, email:" (pr-str email))
  (-> (.post client "/auth/login"
             .data {"email" email "password" password})
      (.then (fn [resp]
               (println "[Auth] login request success, resp.data:" (pr-str (.-data resp)))
               (let [data (.-data resp)
                     token (get data "token")
                     user (get data "user")]
                 (println "[Auth] extracted token:" (pr-str token) "user:" (pr-str user))
                 ;; 1. Inject Token into Dio global config
                 (set-auth-header! token)
                 ;; 2. Save Token and user info; then set user atom and callback
                 (-> (storage/save-auth-data! token user)
                     (.then (fn [_]
                              (set-current-user! (into {} user))
                              (on-success data))))))
      (.catchError (fn [err]
                     (println "[Auth] login request failed err:" (pr-str err))
                     (when-let [resp (safe-get-response err)]
                       (println "[Auth] response status:" (.-statusCode resp))
                       (println "[Auth] response data:" (pr-str (.-data resp))))
                     ;; Possible errors: 401 (wrong password), 404 (user not found)
                     (on-error err)))))

;; Register: API expects user with email, username, password, display_name (see API.md)
(defn register [user-params on-success on-error]
  (println "[Auth] register called, user-params:" (pr-str user-params))
  (let [nickname (or (get user-params "nickname") (get user-params "username") "")
        api-user (-> user-params
                     (dissoc "nickname")
                     (assoc "username" nickname "display_name" nickname))
        payload {"user" api-user}]
    (println "[Auth] request payload:" (pr-str payload))
    (-> (.post client "/auth/register" .data payload)
        (.then (fn [resp]
                 (println "[Auth] register request success, resp.data:" (pr-str (.-data resp)))
                 (let [data (.-data resp)
                       token (get data "token")
                       user (get data "user")]
                   ;; 1. Inject Token into Dio global config
                   (set-auth-header! token)
                   ;; 2. Save Token and user info to SharedPreferences, then 3 & 4
                   (-> (storage/save-auth-data! token user)
                       (.then (fn [_]
                                (set-current-user! (into {} user))
                                (on-success data))))))
        (.catchError (fn [err]
                       (println "[Auth] register request failed err:" (pr-str err))
                       (when-let [resp (safe-get-response err)]
                         (println "[Auth] response status:" (.-statusCode resp))
                         (println "[Auth] response data:" (pr-str (.-data resp))))
                       (on-error err))))))

;; Logout
(defn logout [on-success]
  ;; 1. Clear token from Dio Header
  (set-auth-header! nil)
  ;; 2. Clear current user from atom
  (set-current-user! nil)
  ;; 3. Clear locally persisted token and user info from SharedPreferences
  (-> (storage/clear-auth-data!)
      (.then (fn [_] (on-success true)))
      (.catchError (fn [err]
                     (println "Failed to clear auth data:" err)
                     (on-success true)))))

;; --- Password Management ---

;; Request password reset email
(defn forgot-password [email on-success on-error]
  (-> (.post client "/auth/forgot_password" .data {"email" email})
      (.then (fn [resp] (on-success (into {} (.-data resp)))))
      (.catchError on-error)))

;; Change password using reset token
(defn reset-password [{:keys [token password password-confirmation]} on-success on-error]
  (-> (.post client "/auth/reset_password"
             .data {"token" token
                    "password" password
                    "password_confirmation" password-confirmation})
      (.then (fn [resp] (on-success (into {} (.-data resp)))))
      (.catchError on-error)))

;; Change password while logged in
(defn change-password [{:keys [current-password new-password]} on-success on-error]
  (-> (.post client "/auth/change_password"
             .data {"current_password" current-password
                    "new_password" new-password})
      (.then (fn [resp] (on-success (into {} (.-data resp)))))
      (.catchError on-error)))