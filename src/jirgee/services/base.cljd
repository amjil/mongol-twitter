(ns jirgee.services.base
  (:require ["package:dio/dio.dart" :as dio]
            ["package:mongol_jirgee/database.dart" :as db]
            ["dart:core" :as dc]
            [virtual-keyboard.options :as keyboard-options]
            [virtual-keyboard.input-control :as control]
            [virtual-keyboard.keyboard-candidates :as kc]
            [virtual-keyboard.zip-utils :as zip-utils]
            [virtual-keyboard.fst-reader :as fst-reader]
            [jirgee.state :refer [set-database!] :as state]))

;; Re-export database so other files can import from base.cljd
(def database state/database)

;; --- Network Configuration ---

(def options
  (dio/BaseOptions
   .baseUrl "http://localhost:4000/api/v1"
   .connectTimeout (dc/Duration .seconds 10)
   .receiveTimeout (dc/Duration .seconds 10)
   .headers {"Content-Type" "application/json"}))

;; Global Dio instance
(def client (dio/Dio options))

;; 当前 token，供拦截器读取；Dio 的 headers 必须是 Map<String, dynamic>，不能赋 Clojure map
(def ^:private auth-token-atom (atom nil))

;; 请求拦截器：从 atom 读取 token 并设置到 RequestOptions.headers（Dart Map 上直接 []=
(doto client
  (.interceptors.add
   (dio/InterceptorsWrapper
    .onRequest (fn [options handler]
                 (when-let [token @auth-token-atom]
                   (let [h (.-headers options)]
                     (when h ((.-[]= h) "Authorization" (str "Bearer " token)))))
                 ((.-next handler) options)))))

;; 将 Dio 响应体转为 Clojure map，避免 Dart Map 导致 ICollection 等协议错误
(defn response-data [resp]
  (into {} (.-data resp)))

;; 安全获取错误对象的 response（如果是 DioException），否则返回 nil
;; 内部处理 NoSuchMethodError（Error 类型），避免在调用处需要 catch dynamic
(defn safe-get-response [err]
  (try
    (.-response err)
    (catch Exception _ nil)
    (catch dc/Error _ nil)))

;; Utility function to set authentication token（写入 atom，拦截器会在每次请求时带上）
(defn set-auth-header! [token]
  (reset! auth-token-atom token))

;; --- Database Configuration ---
;; Database state has been moved to jirgee.state

;; Function to initialize database
;; Called at startup in main.cljd
(defn init! [on-success on-error]
  (-> (db/initDriftDatabase)
      (.then (fn [db-instance]
               (set-database! db-instance)
               (on-success db-instance)))
      (.catchError (fn [err]
                     (if on-error
                       (on-error err)
                       (println "Database initialization failed: " err)))))
  (control/set-control)
  (zip-utils/read-json-from-asset-zip kc/next "assets/next.zip")
  (fst-reader/ensure-loaded))

;; --- Common Utilities ---

;; Check if database is ready
(defn db-ready? []
  (not (nil? @database)))

;; Get current database instance
(defn get-db []
  @database)