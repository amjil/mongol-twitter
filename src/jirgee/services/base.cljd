(ns jirgee.services.base
  (:require ["package:dio/dio.dart" :as dio]
            ["package:mongol_jirgee/database.dart" :as db]
            ["dart:core" :as dc]
            [virtual-keyboard.options :as keyboard-options]
            [virtual-keyboard.input-control :as control]
            [virtual-keyboard.keyboard-candidates :as kc]
            [virtual-keyboard.zip-utils :as zip-utils]
            [virtual-keyboard.fst-reader :as fst-reader]
            [jirgee.state :refer [set-database!] :as state]))

;; Re-export database so other files can import from base.cljd
(def database state/database)

;; --- Network Configuration ---

(def options
  (dio/BaseOptions
   .baseUrl "http://localhost:4000/api/v1"
   .connectTimeout (dc/Duration .seconds 10)
   .receiveTimeout (dc/Duration .seconds 10)
   .headers {"Content-Type" "application/json"}))

;; Global Dio instance
(def client (dio/Dio options))

;; Current token for interceptor; Dio headers must be Map<String, dynamic>, not Clojure map
(def ^:private auth-token-atom (atom nil))

;; Request interceptor: read token from atom and set on RequestOptions.headers
(doto client
  (.interceptors.add
   (dio/InterceptorsWrapper
    .onRequest (fn [options handler]
                 (when-let [token @auth-token-atom]
                   (let [h (.-headers options)]
                     (when h ((.-[]= h) "Authorization" (str "Bearer " token)))))
                 ((.-next handler) options)))))

;; Convert Dio response body to Clojure map to avoid ICollection protocol errors with Dart Map
(defn response-data [resp]
  (into {} (.-data resp)))

;; Safely get response from error (if DioException), otherwise nil
;; Handles NoSuchMethodError (Error type) internally so callers need not catch dynamic
(defn safe-get-response [err]
  (try
    (.-response err)
    (catch Exception _ nil)
    (catch dc/Error _ nil)))

;; Set authentication token (written to atom; interceptor adds it to each request)
(defn set-auth-header! [token]
  (reset! auth-token-atom token))

;; --- Database Configuration ---
;; Database state has been moved to jirgee.state

;; Function to initialize database
;; Called at startup in main.cljd
(defn init! [on-success on-error]
  (-> (db/initDriftDatabase)
      (.then (fn [db-instance]
               (set-database! db-instance)
               (on-success db-instance)))
      (.catchError (fn [err]
                     (if on-error
                       (on-error err)
                       (println "Database initialization failed: " err)))))
  (control/set-control)
  (zip-utils/read-json-from-asset-zip kc/next "assets/next.zip")
  (fst-reader/ensure-loaded))

;; --- Common Utilities ---

;; Check if database is ready
(defn db-ready? []
  (not (nil? @database)))

;; Get current database instance
(defn get-db []
  @database)